<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Truthfulness Gauge</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1E1E1E;
            color: #fff;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }

        #gauge-container {
            position: relative;
            width: 300px;
            height: 150px;
            margin-top: 50px;
        }

        /* Create a gauge with clean color sections */
        #gauge-background {
            position: absolute;
            width: 300px;
            height: 150px;
            background: transparent;
            border-top-left-radius: 150px; 
            border-top-right-radius: 150px;
            overflow: hidden;
        }

        #gauge-segments {
            position: absolute;
            width: 300px;
            height: 150px;
            /* Reversed gradient so higher scores (right) point to "TRUE" */
            background: conic-gradient(
                from -90deg,
                #FF0000 0%, 
                #FF0000 25%, 
                #FFA500 25%, 
                #FFA500 50%, 
                #FFD700 50%, 
                #FFD700 75%, 
                #32CD32 75%, 
                #32CD32 100%
            );
            border-radius: 150px 150px 0 0;
            clip-path: polygon(0 50%, 100% 50%, 100% 0, 0 0);
        }

        #gauge-center {
            position: absolute;
            bottom: 0;
            left: 125px;
            width: 50px;
            height: 25px;
            background-color: #1E1E1E;
            border-radius: 25px 25px 0 0;
        }

        #gauge-needle {
            position: absolute;
            bottom: 0;
            left: 150px;
            width: 3px;
            height: 120px;
            background-color: #000000;
            transform-origin: bottom center;
            transform: rotate(0deg);
            transition: transform 1.5s cubic-bezier(0.25, 0.1, 0.25, 1);
            z-index: 3;
        }

        #gauge-needle:after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: -7px;
            width: 17px;
            height: 17px;
            background-color: #000000;
            border: 2px solid #ffffff;
            border-radius: 50%;
        }

        #gauge-text {
            position: absolute;
            bottom: -40px;
            width: 100%;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
        }

        #gauge-percentage {
            position: absolute;
            bottom: -80px;
            width: 100%;
            text-align: center;
            font-size: 40px;
            font-weight: bold;
        }

        .gauge-labels {
            position: absolute;
            width: 300px;
            height: 20px;
            bottom: -20px;
            display: flex;
            justify-content: space-between;
        }

        .gauge-label {
            font-size: 16px;
            font-weight: bold;
        }

        /* Swapped left/right colors to match the new gradient direction */
        .left {
            color: #FF0000;
        }

        .right {
            color: #32CD32;
        }

        #button-container {
            margin-top: 120px;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 12px 20px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            background-color: #2AABEE;
            color: white;
            cursor: pointer;
        }

        #debug {
            margin-top: 20px;
            font-size: 12px;
            color: #888;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Truthfulness Gauge</h1>
    
    <div id="gauge-container">
        <div id="gauge-background">
            <div id="gauge-segments"></div>
        </div>
        <div id="gauge-center"></div>
        <div id="gauge-needle"></div>
        <div class="gauge-labels">
            <!-- Swapped label positions to match new gradient direction -->
            <div class="gauge-label left">BULLSHIT</div>
            <div class="gauge-label right">TRUE</div>
        </div>
        <div id="gauge-text">CHECKING...</div>
        <div id="gauge-percentage">0%</div>
    </div>
    
    <div id="button-container">
        <button id="random-btn">Generate Random Score</button>
        <button id="close-btn">Close</button>
    </div>
    
    <div id="debug"></div>

    <script>
        // Debug element
        const debugEl = document.getElementById('debug');
        
        function log(message) {
            console.log(message);
            debugEl.innerHTML += message + '<br>';
        }
        
        log('Page loaded');
        
        // Initialize Telegram WebApp with fallback for testing outside Telegram
        let tgApp;
        try {
            if (window.Telegram && window.Telegram.WebApp) {
                tgApp = window.Telegram.WebApp;
                tgApp.expand(); // Expand to full screen
                tgApp.ready(); // Tell Telegram WebApp is ready
                log('Telegram WebApp initialized successfully');
            } else {
                log('Telegram WebApp not available - running in standalone mode');
                // Create a mock tgApp for testing outside of Telegram
                tgApp = {
                    expand: () => log('Mock: expand called'),
                    ready: () => log('Mock: ready called'),
                    close: () => log('Mock: close called'),
                    sendData: (data) => log('Mock: sendData called with ' + data)
                };
            }
        } catch (e) {
            log('Error initializing Telegram WebApp: ' + e.message);
            // Create a mock tgApp for error recovery
            tgApp = {
                expand: () => {},
                ready: () => {},
                close: () => alert('App would close here'),
                sendData: (data) => log('Data that would be sent: ' + data)
            };
        }

        // Elements
        const gaugeNeedle = document.getElementById('gauge-needle');
        const gaugeText = document.getElementById('gauge-text');
        const gaugePercentage = document.getElementById('gauge-percentage');
        const randomBtn = document.getElementById('random-btn');
        const closeBtn = document.getElementById('close-btn');

        log('Elements loaded');

        // Truthfulness levels
        const levels = [
            { min: 0, max: 20, text: "COMPLETE BULLSHIT", color: "#FF0000" },
            { min: 20, max: 40, text: "MOSTLY FALSE", color: "#FF4500" },
            { min: 40, max: 60, text: "QUESTIONABLE", color: "#FFA500" },
            { min: 60, max: 80, text: "MOSTLY TRUE", color: "#FFD700" },
            { min: 80, max: 100, text: "FACTUAL", color: "#32CD32" },
            { min: 100, max: 101, text: "ABSOLUTE TRUTH", color: "#32CD32" }
        ];

        // Function to set gauge value (the needle direction logic is now reversed to match the new gradient)
        function setGaugeValue(value) {
            log('Setting gauge value: ' + value);
            
            // Ensure value is between 0 and 100
            const percentage = Math.max(0, Math.min(100, value));
            log('Normalized percentage: ' + percentage);
            
            // Calculate rotation based on percentage (-90deg to 90deg)
            // Now higher percentage means needle points to the right (TRUE)
            const rotation = -90 + (percentage * 180 / 100);
            log('Needle rotation: ' + rotation + 'deg');
            
            // Animate needle
            gaugeNeedle.style.transform = `rotate(${rotation}deg)`;
            
            // Update percentage text
            gaugePercentage.textContent = `${Math.round(percentage)}%`;
            
            // Determine and set text based on percentage
            for (const level of levels) {
                if (percentage >= level.min && percentage < level.max) {
                    gaugeText.textContent = level.text;
                    gaugeText.style.color = level.color;
                    gaugePercentage.style.color = level.color;
                    log('Set level: ' + level.text);
                    break;
                }
            }
            
            // Send data back to Telegram bot if score was generated
            try {
                if (tgApp && typeof tgApp.sendData === 'function') {
                    const dataToSend = JSON.stringify({
                        score: percentage,
                        text: gaugeText.textContent
                    });
                    tgApp.sendData(dataToSend);
                    log('Sent data to Telegram: ' + dataToSend);
                }
            } catch (e) {
                log('Error sending data to Telegram: ' + e.message);
            }
        }

        // Generate a random score
        function generateRandomScore() {
            log('Generating random score');
            const randomScore = Math.floor(Math.random() * 101);
            log('Random score generated: ' + randomScore);
            setGaugeValue(randomScore);
        }

        // Event listeners
        randomBtn.addEventListener('click', function() {
            log('Random button clicked');
            generateRandomScore();
        });
        
        closeBtn.addEventListener('click', function() {
            log('Close button clicked');
            try {
                if (tgApp && typeof tgApp.close === 'function') {
                    tgApp.close();
                    log('Telegram WebApp closed');
                } else {
                    log('Telegram WebApp not available, would close now');
                    alert("This would close the Telegram WebApp");
                }
            } catch (e) {
                log('Error closing WebApp: ' + e.message);
                alert("Unable to close the WebApp properly");
            }
        });

        log('Event listeners added');

        // Check if a score was passed from the bot
        function getScoreFromURL() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const scoreParam = urlParams.get('score');
                log('URL param "score": ' + scoreParam);
                
                if (scoreParam !== null) {
                    const scoreValue = parseFloat(scoreParam);
                    
                    if (!isNaN(scoreValue)) {
                        // Convert the decimal format (0-1) to percentage (0-100)
                        const percentageScore = (scoreValue <= 1) ? scoreValue * 100 : scoreValue;
                        log('Valid score found in URL: ' + scoreValue + ' converted to: ' + percentageScore + '%');
                        return percentageScore;
                    } else {
                        log('Score parameter is not a valid number');
                    }
                } else {
                    log('No score parameter found in URL');
                }
            } catch (e) {
                log('Error parsing URL parameters: ' + e.message);
            }
            
            return null;
        }

        // Initialize the gauge
        function initGauge() {
            log('Initializing gauge');
            const scoreFromURL = getScoreFromURL();
            
            if (scoreFromURL !== null) {
                // If score is provided, use it
                log('Using score from URL: ' + scoreFromURL);
                setGaugeValue(scoreFromURL);
            } else {
                // Default to needle at 0
                setGaugeValue(0);
            }
        }

        // Run initialization
        window.onload = function() {
            log('Window loaded');
            initGauge();
        };
        
        // If window is already loaded, run init now
        if (document.readyState === 'complete') {
            log('Document already complete, running init now');
            initGauge();
        }
    </script>
</body>
</html>
